# JavaScriptOperationalMechanism
## JavaScript运行机制

### 一.JavaScript单线程

##### JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。
##### 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。
  
### 二. 任务队列
##### 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。如果排队是因为计算量大，CPU忙不过来，也就算了。但是很多时候CPU是闲着的，因为IO设备(输入输出设备)很慢(比如Ajax操作从网络读取数据) ，不得不等着结果出来，再往下执行。JavaScript语言的设计者意识到，这是主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。
##### 于是，任务可以分为两种，一种是同步任务(synchronous)，另一种是异步任务(asynchronous)。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"(taskqueue)，只有“任务队列”通知主线程。某个异步任务可以执行了，该任务才会进入主线程执行。
##### 具体来说，异步执行的运行机制如下。(同步执行也是如此，因为它可以被视为没有异步任务的异步执行)

    (1)所有同步任务都在主线程上执行，形成一个执行栈(execution context stack)
    (2)主线程之外，还存在一个“任务队列” (task queue)，只要异步任务有了运行结果，就在“任务队列”之中放置一个事件
    (3)一旦“执行栈”中的所有同步任务执行完毕。系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行
    (4)主线程不断重复上面的第三步
    
##### 主线程和任务队列的示意图如下，只要主线程空了，就会去读取“任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。

### 三.事件和回调函数
##### “任务队列”是一个事件的队列(也可以理解成消息的队列)，IO设备完成一项任务，就在“任务队列”中添加一个事件，表示相关的异步任务可以进入“执行栈”了。主线程读取“任务队列”，就是读取里面有哪些事件。“任务队列”中的时间，除了IO设备的事件以外，还包括一些用户产生的时间(比如：鼠标点击、页面滚动等等)。只要指定过回调函数，这些事件发生时就会进入“任务队列”，等待主线程读取。
##### 所谓“回调函数”(callback)，就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本是自动的，只要执行栈一清空，“任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的“定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的事件，才能返回主线程。
  
### 四.Event Loop
##### 主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop(事件循环)
##### 主线程运行的时候，产生堆(heap)和栈(stack)，栈中的代码调用各种外部的API，它们在“任务队列”中加入各种事件(click，load，done)。只要栈中的代码执行完毕，主线程就会去读取“任务队列”，一次执行那些事件所对应的回调函数。执行栈中的代码(同步任务)，总是在读取“任务队列”(异步任务)之前执行。请看下面的例子：
      var req = new XMLHttpRequest () ;
      req.open('GET',url);
      req.onload = function () {};
      req.onerror = function () {};
      req.send();
##### 上面的代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取“任务队列”。所以，它与下面的写法等价。
      var req = new XMLHttpRequest () ;
      req.open('GET',url);
      req.send();
      req.onload = function () {};
      req.onerror = function () {};
##### 也就是说，指定回调函数的部分(onload和onerror)，在send()方法的前面或后面无关紧要，因为他们属于执行栈的一部分，系统总是执行完它们，才会去读取“任务队列”。
  
### 五. 哪些语句会放入异步任务队列
##### 一般来说，有以下四种会放入异步任务队列：
    1.setTimeout和setInterval
    2.DOM事件
    3.ES6中的Promise
    4.Ajax异步请求
  
### 六.JavaScript代码运行分为两个阶段
##### 1.预解析：把所有的函数定义提前，所有的变量声明提前，变量的赋值不提前
##### 2.执行：从上到下执行，但有例外(setTimeout,setInterval,ajax中的回调函数，事件中的函数需要触发执行)

### 七.定时器
##### 1.定义：
##### 即指定某些代码在多少时间之后执行，叫做“定时器”功能，也就是定时执行的代码。
    setTimeout()：指定的代码是一次执行
    setInterval()：反复执行
##### 2.setTimeout()举例：
  例①：
  
    console.log(1)
    setTimeout(function(){console.log(2),1000})    //setTimeout(function(){console.log(2),0})
    console.log(3)
    输出结果：1 3 2
    分析：setTimeout()将第二行代码推迟到1000毫秒之后执行，如果将setTimeout()的第二个参数设为0，就代表当前代码执行完(执行栈清空)之后，立即执行(0毫秒间隔)指定的回调函数。setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是尽可能早的执行，它在“任务队列”的尾部添加一个时间，因此要等到同步任务和任务队列现有的事件都处理完，才会得到执行。

  例②：
    
    $.ajax({
    url: 'xxxx',
    success.function(result){
    console.log('a')
    }
    }) // ajax加载完成被放入 异步队列
    setTimeout(function(){console.log('b')},100)  //100ms之后被放入 异步队列
    setTimeout(function(){console.log('c')})  //立刻被放入 异步队列
    console.log('d')  // 主进程
    输出结果：d c b a (大于100ms) 或  d c a b(小于100ms)
    分析：ajax加载完成时才会放入异步队列，至于这段时间不确定，所以有两种情况
    
##### 3.说明：
##### HTML5标准规定了setTimeout()的第二个参数的最小值(最短间隔)，不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动(尤其是涉及页面重新渲染的部分)，通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。
##### 需要注意的是，setTimeout()只是将事件插入了“任务队列”，必须等到当前代码(执行栈)执行完，主线程才会执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。
##### 4.for循环与setTimeout
  例③：
    
    for(let i = 0;i<5;i++){
      setTimeout(function(){
        console.log(i)
      })
    }
    输出结果：5 5 5 5 5
##### 如果想要输出的结果是0~4，怎样修改？
  方法一：将var变成let
  
    for(let i = 0;i<5;i++){
      setTimeout(function(){
      console.log(i)
      })
    }
  方法二：加个立即执行函数
  
    for(var i = 0;i<5;i++){
      (function(i){
        setTimeout(function(){
          console.log(i)
      },1000);
      })(i)
    }
  方法三：加闭包
  
    for(var i = 0;i<5;i++){
      var a = function(){
        var j = i;
        setTimeout(function(){
          console.log(j)
        },1000)
      }
      a();
    }

